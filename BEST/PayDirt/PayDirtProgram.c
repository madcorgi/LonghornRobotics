#pragma config(Motor,  port2,           RightDriveMotor, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           LeftDriveMotor, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           LiftMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           OpenClawServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           RotateClawServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           TrapDoorServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           CargoBinMotor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//And major modifications made by Samuel Wait
void moveServo(int servoId, bool moveClockwise)
{
	short increment;
	short position;
	if (moveClockwise == true)
	{
		increment = 10;
	}
	else
	{
		increment = -10;
	}

	position = motor[servoId] + increment;

	if (position < 128 && position > -128)
	{
		motor[servoId] += increment;
	  wait1Msec(50);
	}
}

//EDITABLE VARIABLES
bool slowDriveSpeed = false;
int liftspeed = 50; // Changes the initial speed of the lift
int minliftspeed = 40; // The minimum speed of the lift (Too much under 40 and it won't lift at all. I suggest you keep it there
int maxliftspeed = 100; // The maximum speed of the lift (I'm not sure if it even works over 100. Keep this at at least 100)

task main()
{

	while (true) // Why have 1==1 instead of just having true... sheesh
	{
		if (vexRT[Btn6U] == 1)
		{
			slowDriveSpeed = false;
		}
		else if (vexRT[Btn6D] == 1)
		{
			slowDriveSpeed = true;
		}

		//STEERING METHODS
		//To change the steering controls, uncomment the second two lines of ONE of the following blocks (remove the '//')
		//Make sure the other blocks are commented out

		if (slowDriveSpeed == true)
		{
			//Original Steering Method (Katamari Damacy)
			//motor[LeftDriveMotor] = vexRT[Ch3] / 2;
			//motor[RightDriveMotor] = vexRT[Ch2] / 2;

			//Alternate Steering Method: Left Joystick ( MarioKart)
			motor[LeftDriveMotor] = (vexRT[Ch2] + vexRT[Ch4]) / 2;
			motor[RightDriveMotor] = (vexRT[Ch3] -  vexRT[Ch4]) / 2;

			//Alternate Steering Method: Right Joystick ( MarioKart)
			//motor[LeftDriveMotor] = (vexRT[Ch2] + vexRT[Ch1]) / 2;
			//motor[RightDriveMotor] = (vexRT[Ch2] -  vexRT[Ch1]) / 2;


		}
		else
		{
			//Original Steering Method (Katamari Damacy)
			//motor[LeftDriveMotor] = vexRT[Ch3];
			//motor[RightDriveMotor] = vexRT[Ch2];

			//Alternate Steering Method: Left Joystick ( MarioKart)
			motor[LeftDriveMotor] = vexRT[Ch2] + vexRT[Ch4];
			motor[RightDriveMotor] = vexRT[Ch3] -  vexRT[Ch4];

			//Alternate Steering Method: Right Joystick ( MarioKart)
			//motor[LeftDriveMotor] = vexRT[Ch2] + vexRT[Ch1];
			//motor[RightDriveMotor] = vexRT[Ch2] -  vexRT[Ch1];


		}
		//wait1Msec(100);

		//LIFT MOTOR CONTROLS
		//The Left Trigger is used to raise and lower the lift,
				//Top Button: Raise
				//Lower Button: Lower
		//The Left Button Pad controls the speed of the lift
				// Down : Decrase Speed
				// Up : Increase Speed
				//Left: Jump to Minimum Speed
				//Right: Jump To Maximum Speed


		if (vexRT[Btn5U] == 1)
		{
			motor[LiftMotor] = liftspeed; // made motor speed adjustable here
			//Slowest properly working speed is 40
		}
		else if (vexRT[Btn5D] == 1)
		{
			motor[LiftMotor] = -liftspeed; // did the same here
		}
		else // If the motor isn't moving...
    {
    	 if (vexRT[Btn7U] == 1)
			{
				liftspeed = liftspeed + 10; // Increasing the motor speed
				if(liftspeed > maxliftspeed)
				{
					liftspeed = maxliftspeed; // So the robot's arm never becomes way too fast
				}
				else // No need to delay if it's at the maximum speed, It wont' accelerate too much
				{
					wait1Msec(200);//To make sure it doesn't rapidly increase when the button is pressed
				}
				//You can only adjust the motor speed while it's not moving, don't want to break something!
				wait1Msec(100);//Even if it's at the max speed, I don't want somebody holding down the button and causing it to loop too fast and fry itself
			}
			else if (vexRT[Btn7D] == 1)
			{
				liftspeed = liftspeed - 10; // decreasing the motor speed
				if(liftspeed < minliftspeed)
				{
					liftspeed = minliftspeed; // So the robot's arm never becomes too slow to be operational... or even go negative!
				}
				else // No need to delay as much if it's at the minimum speed and not changing
				{
					wait1Msec(200);//To make sure it doens't rapidly decrease when the button is pressed
				}
					wait1Msec(100);//Even if it's at the max speed, I don't want somebody holding down the button and causing it too loop to fast and fry itself
			}
			else if (vexRT[Btn7L] == 1)
			{
				liftspeed = minliftspeed; // Jumps the lift speed down to the minimum
				wait1Msec(100);
			}
			else if (vexRT[Btn7R] == 1)
			{
				liftspeed = maxliftspeed; // Jumps the lift speed up to the maximum
				wait1Msec(100);
			}
			motor[LiftMotor] = 0;
		}

		if (vexRT[Btn8U] == 1)
		{
			motor[CargoBinMotor] = minliftspeed;
			wait1Msec(200);
			motor[CargoBinMotor] = 0;
		}
		else if (vexRT[Btn8D] == 1)
		{
			motor[CargoBinMotor] = -minliftspeed;
			wait1Msec(200);
			motor[CargoBinMotor] = 0;
		}

		//SERVO CONTROLS

		//if (vexRT[Btn8U] == 1)
		//{
		//	moveServo(OpenClawServo, false);
		//}
		//else if (vexRT[Btn8D] == 1)
		//{
		//	moveServo(OpenClawServo, true);
		//}

		//if (vexRT[Btn8L] == 1)
		//{
		//	moveServo(RotateClawServo, true);
		//}
		//else if (vexRT[Btn8R] == 1)
		//{
		//	moveServo(RotateClawServo, true);
		//}

		if (vexRT[Btn8L] == 1)
		{
			moveServo(TrapDoorServo, false);
		}
		else if (vexRT[Btn8R] == 1)
		{
			moveServo(TrapDoorServo, true);
		}
	}//end of loop
}
