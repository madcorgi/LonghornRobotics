#pragma config(Motor,  port2,           RightDriveMotor, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           LeftDriveMotor, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           LiftMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           OpenClawServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           RotateClawServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           TrapDoorServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           CargoBinMotor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//And major modifications made by Samuel Wait
/*
void moveServo(int servoId, bool moveClockwise)
{
	short increment;
	short position;
	if (moveClockwise == true)
	{
		increment = 10;
	}
	else
	{
		increment = -10;
	}

	position = motor[servoId] + increment;

	if (position < 128 && position > -128)
	{
		motor[servoId] += increment;
	  wait1Msec(50);
	}
}
*/



bool doubTapCheck(TVexJoysticks button) // Checks to see if a button has been double tapped
{
				bool check1 = false;
				bool check2 = false;
				for (int i = 1; i < 250; i++) // Loops to check a lot of times so whenever the second button is pressed it is registered
				{
					if (vexRT[button] == 0)
					{
						check1 = true;
						break;
					}
					wait1Msec(2);
				}

				for (int i = 1; i < 250; i++) // Loops to check a lot of times so whenever the second button is pressed it is registered
				{
					if (vexRT[button] == 1)
					{
						check2 = true;
						break;
					}
					wait1Msec(2);
				}
				return (check1 && check2);
}

void toggleServo(int servoId)
{
	short increment;
	short position;

	if (motor[servoId] < 0) // Checks to see the current position of the servo and determines direction accordingly
	{
		increment = 10;
	}
	else
	{
		increment = -10;
	}

	while(true)
	{

		position = motor[servoId] + increment; // Future hypothetical position

		if (position < 128 && position > -128) // Makes sure it doesn't go past physical limits
		{
			motor[servoId] += increment;
		  wait1Msec(50);
		}
		else
		{
			break; // Escapes when it has hit the limit
		}
	}
}

bool dumpable = true;

//EDITABLE VARIABLES
bool slowDriveSpeed = false;
int liftspeed = 50; // Changes the initial speed of the lift
int minliftspeed = 40; // The minimum speed of the lift (Too much under 40 and it won't lift at all. I suggest you keep it there
int maxliftspeed = 100; // The maximum speed of the lift (I'm not sure if it even works over 100. Keep this at at least 100)


task main()
{

	while (true) // Why have 1==1 instead of just having true... sheesh
	{

		if (vexRT[Btn6U] == 1) // Enter half speed mode
		{
			if(slowDriveSpeed)
			{
				slowDriveSpeed = false;
			}
			else
			{
				slowDriveSpeed = true;
			}
			wait1Msec(300);
		}


		//STEERING METHODS
		//To change the steering controls, uncomment the second two lines of ONE of the following blocks (remove the '//')
		//Make sure the other blocks are commented out
		int driveSpeedFraction = 1;
		if (slowDriveSpeed)
		{
			driveSpeedFraction = 2;
		}

			//Original Steering Method (Katamari Damacy)
			//motor[LeftDriveMotor] = vexRT[Ch3] / driveSpeedFraction;
			//motor[RightDriveMotor] = vexRT[Ch2] / driveSpeedFraction;

		//Alternate Steering Method: Left Joystick ( MarioKart)
			motor[LeftDriveMotor] = (vexRT[Ch3] + vexRT[Ch4]) / driveSpeedFraction;
			motor[RightDriveMotor] = (vexRT[Ch3] -  vexRT[Ch4]) / driveSpeedFraction;

			//Alternate Steering Method: Right Joystick ( MarioKart)
			//motor[LeftDriveMotor] = (vexRT[Ch2] + vexRT[Ch1]) / driveSpeedFraction;
			//motor[RightDriveMotor] = (vexRT[Ch2] -  vexRT[Ch1]) / driveSpeedFracti01on;


		//wait1Msec(100);

		//LIFT MOTOR CONTROLS
		//The Left Trigger is used to raise and lower the lift,
				//Top Button: Raise
				//Lower Button: Lower
		//The Left Button Pad controls the speed of the lift
				// Down : Decrase Speed
				// Up : Increase Speed
				//Left: Jump to Minimum Speed
				//Right: Jump To Maximum Speed


		if (vexRT[Btn5U] == 1)
		{
			motor[LiftMotor] = liftspeed; // made motor speed adjustable here
			//Slowest properly working speed is 40
		}
		else if (vexRT[Btn5D] == 1)
		{
			motor[LiftMotor] = -liftspeed; // did the same here
		}
		else // If the motor isn't moving...
    {
    	 if (vexRT[Btn7U] == 1)
			{
				if (doubTapCheck(Btn7U))  //This can also act as a 500ms delay to stop the circuit from frying
				{
				liftspeed = maxliftspeed; // Jumps the lift speed up to the maximum
				}
				else
				{
					liftspeed = liftspeed + 10; // Increasing the motor speed
					if(liftspeed > maxliftspeed)
					{
						liftspeed = maxliftspeed; // So the robot's arm never becomes way too fast
					}
				}
					//You can only adjust the motor speed while it's not moving, don't want to break something!

			}
			else if (vexRT[Btn7D] == 1)
			{
				if (doubTapCheck(Btn7D)) //This can also act as a 500ms delay to stop the circuit from frying
				{
					liftspeed = minliftspeed; // Jumps the lift speed down to the minimum
				}
				else
				{
					liftspeed = liftspeed - 10; // decreasing the motor speed

					if(liftspeed < minliftspeed)
					{
						liftspeed = minliftspeed; // So the robot's arm never becomes too slow to be operational... or even go negative!
					}
				}

			}
			/*else if (vexRT[Btn7L] == 1)
			{
				liftspeed = minliftspeed; // Jumps the lift speed down to the minimum
				wait1Msec(100);
			}
		else if (vexRT[Btn7R] == 1)
			{
				liftspeed = maxliftspeed; // Jumps the lift speed up to the maximum
				wait1Msec(100);
		}*/
			motor[LiftMotor] = 0;
		}

		if (vexRT[Btn8U] == 1)
		{
			if (dumpable) // Makes it actiavte only by single button presses
				{
				motor[CargoBinMotor] = 60;
				wait1Msec(500);
				/*motor[CargoBinMotor] = 20; // Pauses and moves again in case the rod bounces off.
				wait1Msec(100);
				*/
				motor[CargoBinMotor] = 0;
				dumpable = false;
			}
		}
		else if (vexRT[Btn8D] == 1)
		{
			if (dumpable) // Makes it actiavte only by single button presses
				{
				motor[CargoBinMotor] = -40;
				wait1Msec(500);
				motor[CargoBinMotor] = 0;
				dumpable = false;
			}
		}
		else
		{
			dumpable = true; // Makes it so pressing the button will make it work again
		}

		//SERVO CONTROLS

		//if (vexRT[Btn8U] == 1)
		//{
		//	moveServo(OpenClawServo, false);
		//}
		//else if (vexRT[Btn8D] == 1)
		//{
		//	moveServo(OpenClawServo, true);
		//}

		//if (vexRT[Btn8L] == 1)
		//{
		//	moveServo(RotateClawServo, true);
		//}
		//else if (vexRT[Btn8R] == 1)
		//{
		//	moveServo(RotateClawServo, true);
		//}






		if (vexRT[Btn8R] == 1)
		{
			toggleServo(TrapDoorServo); // Calls the toggle function up on top
		/*else if (vexRT[Btn8R] == 1)
		{
			moveServo(TrapDoorServo, true);
		*/
		}
	}//end of loop
}
